
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>config: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">temp/config/db.go (0.0%)</option>
				
				<option value="file1">temp/config/redis.go (0.0%)</option>
				
				<option value="file2">temp/config/system.go (0.0%)</option>
				
				<option value="file3">temp/core/viber.go (0.0%)</option>
				
				<option value="file4">temp/docs/docs.go (0.0%)</option>
				
				<option value="file5">temp/handlers/user_handler.go (75.0%)</option>
				
				<option value="file6">temp/main.go (0.0%)</option>
				
				<option value="file7">temp/middlewares/auth.go (0.0%)</option>
				
				<option value="file8">temp/middlewares/logging.go (0.0%)</option>
				
				<option value="file9">temp/middlewares/recovery.go (0.0%)</option>
				
				<option value="file10">temp/repositories/user_repo.go (5.9%)</option>
				
				<option value="file11">temp/routes/router.go (0.0%)</option>
				
				<option value="file12">temp/services/user_service.go (64.5%)</option>
				
				<option value="file13">temp/testutils/test_helpers.go (0.0%)</option>
				
				<option value="file14">temp/utils/hash.go (85.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package config

import (
        "fmt"

        "gorm.io/driver/mysql"
        "gorm.io/gorm"
)

// InitDB initializes and returns a *gorm.DB based on config (sqlite by default)
func InitDB(cfg *Config) (*gorm.DB, error) <span class="cov0" title="0">{
        switch cfg.DB.Driver </span>{
        case "mysql":<span class="cov0" title="0">
                db, err := gorm.Open(mysql.Open(cfg.DB.DSN), &amp;gorm.Config{})
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to connect mysql: %w", err)
                }</span>
                <span class="cov0" title="0">return db, nil</span>
        default:<span class="cov0" title="0">
                // default to mysql if driver is not specified or recognized
                db, err := gorm.Open(mysql.Open(cfg.DB.DSN), &amp;gorm.Config{})
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to connect default mysql: %w", err)
                }</span>
                <span class="cov0" title="0">return db, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package config

import (
        "context"
        "fmt"

        "github.com/redis/go-redis/v9"

        "temp/global"
)

func InitRedis(cfg *Config) error <span class="cov0" title="0">{
        if !cfg.Redis.Enabled </span><span class="cov0" title="0">{
                return nil // Redis is disabled, return without error
        }</span>

        <span class="cov0" title="0">global.Redis = redis.NewClient(&amp;redis.Options{
                Addr:     cfg.Redis.Addr,
                Password: cfg.Redis.Password,
                DB:       cfg.Redis.DB,
        })

        ctx := context.Background()
        if err := global.Redis.Ping(ctx).Err(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to ping redis: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package config

import (
        "fmt"

        "github.com/spf13/viper"
)

// Config holds application configuration
type Config struct {
        Server struct {
                Port string `mapstructure:"port"`
        } `mapstructure:"server"`
        DB struct {
                Driver string `mapstructure:"driver"`
                DSN    string `mapstructure:"dsn"`
        } `mapstructure:"db"`
        Redis struct {
                Enabled  bool   `mapstructure:"enabled"`
                Addr     string `mapstructure:"addr"`
                Password string `mapstructure:"password"`
                DB       int    `mapstructure:"db"`
        } `mapstructure:"redis"`
        JWT struct {
                Secret          string `mapstructure:"secret"`
                ExpirationHours int    `mapstructure:"expiration_hours"`
        } `mapstructure:"jwt"`
}

// LoadConfig reads configuration from file
func LoadConfig(path string) (*Config, error) <span class="cov0" title="0">{
        v := viper.New()
        v.SetConfigFile(path)
        v.AutomaticEnv()

        if err := v.ReadInConfig(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error reading config file: %w", err)
        }</span>

        <span class="cov0" title="0">var cfg Config
        if err := v.Unmarshal(&amp;cfg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to decode into struct: %w", err)
        }</span>

        <span class="cov0" title="0">if cfg.Server.Port == "" </span><span class="cov0" title="0">{
                cfg.Server.Port = ":8080"
        }</span>

        <span class="cov0" title="0">if cfg.DB.Driver == "" </span><span class="cov0" title="0">{
                cfg.DB.Driver = "mysql"
        }</span>

        <span class="cov0" title="0">return &amp;cfg, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package core

func DoViberStuff(payload string) string <span class="cov0" title="0">{
        // simulation of some processing
        return "Processed: " + payload
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "termsOfService": "http://swagger.io/terms/",
        "contact": {
            "name": "API Support",
            "url": "http://www.swagger.io/support",
            "email": "support@swagger.io"
        },
        "license": {
            "name": "MIT",
            "url": "https://opensource.org/licenses/MIT"
        },
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/login": {
            "post": {
                "description": "Authenticate user with email and password",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Authentication"
                ],
                "summary": "User login",
                "parameters": [
                    {
                        "description": "User login credentials",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "object",
                            "properties": {
                                "email": {
                                    "type": "string"
                                },
                                "password": {
                                    "type": "string"
                                }
                            }
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Login successful",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "token": {
                                    "type": "string"
                                },
                                "user": {
                                    "type": "object",
                                    "properties": {
                                        "email": {
                                            "type": "string"
                                        },
                                        "id": {
                                            "type": "integer"
                                        },
                                        "name": {
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "Bad request - validation error",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                }
                            }
                        }
                    },
                    "401": {
                        "description": "Unauthorized - invalid credentials",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                }
                            }
                        }
                    }
                }
            }
        },
        "/profile": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Get the profile information of the authenticated user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "Get user profile",
                "responses": {
                    "200": {
                        "description": "Profile retrieved successfully",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "message": {
                                    "type": "string"
                                },
                                "user_id": {
                                    "type": "integer"
                                }
                            }
                        }
                    },
                    "401": {
                        "description": "Unauthorized - invalid or missing token",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                }
                            }
                        }
                    }
                }
            }
        },
        "/register": {
            "post": {
                "description": "Create a new user account with email and password",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Authentication"
                ],
                "summary": "Register a new user",
                "parameters": [
                    {
                        "description": "User registration data",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "object",
                            "properties": {
                                "email": {
                                    "type": "string"
                                },
                                "name": {
                                    "type": "string"
                                },
                                "password": {
                                    "type": "string"
                                }
                            }
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "User successfully registered",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "email": {
                                    "type": "string"
                                },
                                "id": {
                                    "type": "integer"
                                },
                                "name": {
                                    "type": "string"
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "Bad request - validation error",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                }
                            }
                        }
                    },
                    "409": {
                        "description": "Conflict - user already exists",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                }
                            }
                        }
                    }
                }
            }
        },
        "/set-redis-key": {
            "post": {
                "description": "Store a key-value pair in Redis cache",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Redis"
                ],
                "summary": "Set Redis key-value pair",
                "parameters": [
                    {
                        "description": "Redis key-value data",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "object",
                            "properties": {
                                "key": {
                                    "type": "string"
                                },
                                "value": {
                                    "type": "string"
                                }
                            }
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Key set successfully",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "key": {
                                    "type": "string"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "value": {
                                    "type": "string"
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "Bad request - validation error",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "Internal server error - Redis operation failed",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                }
                            }
                        }
                    }
                }
            }
        }
    },
    "securityDefinitions": {
        "BearerAuth": {
            "description": "Type \"Bearer\" followed by a space and JWT token.",
            "type": "apiKey",
            "name": "Authorization",
            "in": "header"
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "1.0.0",
        Host:             "localhost:8080",
        BasePath:         "/api/v1",
        Schemes:          []string{},
        Title:            "User Management API",
        Description:      "A comprehensive API for user management with authentication, registration, and profile management",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package handlers

import (
        "fmt"
        "net/http"
        "strconv"

        "temp/services"

        "github.com/gin-gonic/gin"
        "temp/global"
)

type UserHandler struct {
        service services.UserServiceInterface
}

func NewUserHandler(s services.UserServiceInterface) *UserHandler <span class="cov8" title="1">{
        return &amp;UserHandler{service: s}
}</span>

// Register godoc
// @Summary Register a new user
// @Description Create a new user account with email and password
// @Tags Authentication
// @Accept json
// @Produce json
// @Param request body object{name=string,email=string,password=string} true "User registration data"
// @Success 201 {object} object{id=int,name=string,email=string} "User successfully registered"
// @Failure 400 {object} object{error=string} "Bad request - validation error"
// @Failure 409 {object} object{error=string} "Conflict - user already exists"
// @Router /register [post]
func (h *UserHandler) Register(c *gin.Context) <span class="cov8" title="1">{
        var req struct {
                Name     string `json:"name" binding:"required"`
                Email    string `json:"email" binding:"required,email"`
                Password string `json:"password" binding:"required,min=6"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">u, err := h.service.Register(req.Name, req.Email, req.Password)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusCreated, gin.H{"id": u.ID, "name": u.Name, "email": u.Email})</span>
}

// Login godoc
// @Summary User login
// @Description Authenticate user with email and password
// @Tags Authentication
// @Accept json
// @Produce json
// @Param request body object{email=string,password=string} true "User login credentials"
// @Success 200 {object} object{token=string,user=object{id=int,email=string,name=string}} "Login successful"
// @Failure 400 {object} object{error=string} "Bad request - validation error"
// @Failure 401 {object} object{error=string} "Unauthorized - invalid credentials"
// @Router /login [post]
func (h *UserHandler) Login(c *gin.Context) <span class="cov8" title="1">{
        var req struct {
                Email    string `json:"email" binding:"required,email"`
                Password string `json:"password" binding:"required"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">token, u, err := h.service.Authenticate(req.Email, req.Password)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid credentials"})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{"token": token, "user": gin.H{"id": u.ID, "email": u.Email, "name": u.Name}})</span>
}

// Profile godoc
// @Summary Get user profile
// @Description Get the profile information of the authenticated user
// @Tags User
// @Accept json
// @Produce json
// @Security BearerAuth
// @Success 200 {object} object{message=string,user_id=int} "Profile retrieved successfully"
// @Failure 401 {object} object{error=string} "Unauthorized - invalid or missing token"
// @Router /profile [get]
func (h *UserHandler) Profile(c *gin.Context) <span class="cov8" title="1">{
        userIDRaw, exists := c.Get("user_id")
        if !exists </span><span class="cov8" title="1">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "no user in context"})
                return
        }</span>

        <span class="cov8" title="1">userID := uint(0)
        switch v := userIDRaw.(type) </span>{
        case float64:<span class="cov8" title="1">
                userID = uint(v)</span>
        case string:<span class="cov8" title="1">
                if id, err := strconv.Atoi(v); err == nil </span><span class="cov8" title="1">{
                        userID = uint(id)
                }</span>
        case int:<span class="cov0" title="0">
                userID = uint(v)</span>
        case uint:<span class="cov8" title="1">
                userID = v</span>
        }

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{"message": "this is a protected route", "user_id": userID})</span>
}

// SetRedisKey godoc
// @Summary Set Redis key-value pair
// @Description Store a key-value pair in Redis cache
// @Tags Redis
// @Accept json
// @Produce json
// @Param request body object{key=string,value=string} true "Redis key-value data"
// @Success 200 {object} object{message=string,key=string,value=string} "Key set successfully"
// @Failure 400 {object} object{error=string} "Bad request - validation error"
// @Failure 500 {object} object{error=string} "Internal server error - Redis operation failed"
// @Router /set-redis-key [post]
func (h *UserHandler) SetRedisKey(c *gin.Context) <span class="cov0" title="0">{
        var req struct {
                Key   string `json:"key" binding:"required"`
                Value string `json:"value" binding:"required"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">ctx := c.Request.Context()
        if err := global.Redis.Set(ctx, req.Key, req.Value, 0).Err(); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("failed to set key in redis: %v", err)})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "key set successfully", "key": req.Key, "value": req.Value})</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Package main provides a REST API for user management
// @title User Management API
// @version 1.0.0
// @description A comprehensive API for user management with authentication, registration, and profile management
// @termsOfService http://swagger.io/terms/

// @contact.name API Support
// @contact.url http://www.swagger.io/support
// @contact.email support@swagger.io

// @license.name MIT
// @license.url https://opensource.org/licenses/MIT

// @host localhost:8080
// @BasePath /api/v1

// @securityDefinitions.apikey BearerAuth
// @in header
// @name Authorization
// @description Type "Bearer" followed by a space and JWT token.

package main

import (
        "fmt"
        "log"

        "temp/config"
        "temp/docs"
        "temp/global"
        "temp/handlers"
        "temp/repositories"
        "temp/routes"
        "temp/services"
)

func main() <span class="cov0" title="0">{
        log.Println("Starting application initialization...")
        
        // Initialize Swagger docs
        docs.SwaggerInfo.Title = "User Management API"
        docs.SwaggerInfo.Description = "A comprehensive API for user management with authentication, registration, and profile management"
        docs.SwaggerInfo.Version = "1.0.0"
        docs.SwaggerInfo.Host = "localhost:8080"
        docs.SwaggerInfo.BasePath = "/api/v1"
        docs.SwaggerInfo.Schemes = []string{"http"}
        
        // Load configuration
        log.Println("Loading configuration...")
        cfg, err := config.LoadConfig("./config.yaml")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error loading configuration: %v", err)
        }</span>
        <span class="cov0" title="0">log.Println("Configuration loaded.")

        // init db
        log.Println("Initializing database...")
        db, err := config.InitDB(cfg)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("db init error: %v", err)
        }</span>
        <span class="cov0" title="0">global.DB = db
        log.Println("Database initialized.")

        // Init Redis
        log.Println("Initializing Redis...")
        if err = config.InitRedis(cfg); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error initializing Redis: %v", err)
        }</span>
        // global.RedisClient = rdb // No longer needed as InitRedis directly sets global.Redis
        <span class="cov0" title="0">log.Println("Redis initialized.")

        // repos, services, handlers
        log.Println("Initializing repositories, services, and handlers...")
        userRepo := repositories.NewUserRepo()
        if err := userRepo.Migrate(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("migration failed: %v", err)
        }</span>

        <span class="cov0" title="0">userService := services.NewUserService(userRepo, cfg.JWT.Secret, cfg.JWT.ExpirationHours)
        userHandler := handlers.NewUserHandler(userService)
        log.Println("Repositories, services, and handlers initialized.")

        r := routes.NewRouter(userHandler, cfg.JWT.Secret)

        fmt.Println("Server listening on", cfg.Server.Port)
        if err := r.Run(cfg.Server.Port); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to run server: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package middlewares

import (
        "net/http"
        "strings"

        "github.com/gin-gonic/gin"
        "github.com/golang-jwt/jwt/v5"
)

// AuthMiddleware returns a gin middleware that validates JWT tokens
func AuthMiddleware(secret string) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                auth := c.GetHeader("Authorization")
                if auth == "" </span><span class="cov0" title="0">{
                        c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "missing authorization header"})
                        return
                }</span>

                <span class="cov0" title="0">parts := strings.SplitN(auth, " ", 2)
                if len(parts) != 2 || strings.ToLower(parts[0]) != "bearer" </span><span class="cov0" title="0">{
                        c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "invalid auth header"})
                        return
                }</span>

                <span class="cov0" title="0">tokStr := parts[1]
                tok, err := jwt.Parse(tokStr, func(t *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                        if _, ok := t.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                                return nil, nil
                        }</span>
                        <span class="cov0" title="0">return []byte(secret), nil</span>
                })
                <span class="cov0" title="0">if err != nil || !tok.Valid </span><span class="cov0" title="0">{
                        c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "invalid token"})
                        return
                }</span>

                <span class="cov0" title="0">if claims, ok := tok.Claims.(jwt.MapClaims); ok </span><span class="cov0" title="0">{
                        c.Set("user_id", claims["sub"])
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package middlewares

import (
        "time"

        "github.com/gin-gonic/gin"
)

func LoggingMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                start := time.Now()
                c.Next()
                latency := time.Since(start)
                status := c.Writer.Status()
                method := c.Request.Method
                path := c.Request.URL.Path
                // simple print — يمكنك تبديله بلوغر متقدم
                println("[HTTP] ", method, path, "status:", status, "latency:", latency.String())
        }</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package middlewares

import (
        "net/http"

        "github.com/gin-gonic/gin"
)

func RecoveryMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                c.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{"error": "internal server error"})
                        }</span>
                }()
                <span class="cov0" title="0">c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package repositories

import (
        "errors"
        "temp/global"
        "temp/models"

        "gorm.io/gorm"
)

var ErrUserNotFound = errors.New("user not found")

// UserRepo handles DB operations for users
type UserRepo struct{}

// Ensure UserRepo implements UserRepository interface
var _ UserRepository = (*UserRepo)(nil)

func NewUserRepo() *UserRepo <span class="cov8" title="1">{
        return &amp;UserRepo{}
}</span>

func (r *UserRepo) Migrate() error <span class="cov0" title="0">{
        return global.DB.AutoMigrate(&amp;models.User{})
}</span>

func (r *UserRepo) Create(u *models.User) error <span class="cov0" title="0">{
        return global.DB.Create(u).Error
}</span>

func (r *UserRepo) FindByEmail(email string) (*models.User, error) <span class="cov0" title="0">{
        var u models.User
        res := global.DB.Where("email = ?", email).First(&amp;u)
        if res.Error != nil </span><span class="cov0" title="0">{
                if errors.Is(res.Error, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, ErrUserNotFound
                }</span>
                <span class="cov0" title="0">return nil, res.Error</span>
        }
        <span class="cov0" title="0">return &amp;u, nil</span>
}

func (r *UserRepo) FindByID(id uint) (*models.User, error) <span class="cov0" title="0">{
        var u models.User
        res := global.DB.First(&amp;u, id)
        if res.Error != nil </span><span class="cov0" title="0">{
                if errors.Is(res.Error, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, ErrUserNotFound
                }</span>
                <span class="cov0" title="0">return nil, res.Error</span>
        }
        <span class="cov0" title="0">return &amp;u, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package routes

import (
        "temp/handlers"
        "temp/middlewares"

        "github.com/gin-gonic/gin"
        ginSwagger "github.com/swaggo/gin-swagger"
        swaggerFiles "github.com/swaggo/files"
)

func NewRouter(userHandler *handlers.UserHandler, jwtSecret string) *gin.Engine <span class="cov0" title="0">{
        r := gin.New()
        r.Use(gin.Recovery())
        r.Use(middlewares.LoggingMiddleware())
        r.Use(middlewares.RecoveryMiddleware())

        // Swagger documentation endpoint
        r.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))

        v1 := r.Group("/api/v1")
        </span><span class="cov0" title="0">{
                v1.POST("/register", userHandler.Register)
                v1.POST("/login", userHandler.Login)
                v1.GET("/profile", middlewares.AuthMiddleware(jwtSecret), userHandler.Profile)
                v1.POST("/set-redis-key", userHandler.SetRedisKey)
        }</span>

        <span class="cov0" title="0">return r</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package services

import (
        "context"
        "errors"
        "fmt"
        "time"

        "temp/global"
        "temp/models"
        "temp/repositories"
        "temp/utils"

        "github.com/golang-jwt/jwt/v5"
)

var (
        ErrInvalidCredentials = errors.New("invalid credentials")
)

type UserService struct {
        repo        repositories.UserRepository
        jwtSecret   string
        expDuration time.Duration
}

// Ensure UserService implements UserServiceInterface interface
var _ UserServiceInterface = (*UserService)(nil)

func NewUserService(repo repositories.UserRepository, jwtSecret string, expHours int) *UserService <span class="cov8" title="1">{
        return &amp;UserService{
                repo:        repo,
                jwtSecret:   jwtSecret,
                expDuration: time.Duration(expHours) * time.Hour,
        }
}</span>

func (s *UserService) Register(name, email, password string) (*models.User, error) <span class="cov8" title="1">{
        // check if exists
        if _, err := s.repo.FindByEmail(email); err == nil </span><span class="cov8" title="1">{
                return nil, errors.New("user already exists")
        }</span>

        <span class="cov8" title="1">hash, err := utils.GenerateHash(password)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">u := &amp;models.User{
                Name:     name,
                Email:    email,
                Password: hash,
        }

        if err := s.repo.Create(u); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store user registration in Redis for demonstration
        <span class="cov8" title="1">if global.Redis != nil </span><span class="cov0" title="0">{
                ctx := context.Background()
                redisKey := fmt.Sprintf("user:registered:%s", u.Email)
                if err := global.Redis.Set(ctx, redisKey, u.ID, 10*time.Minute).Err(); err != nil </span><span class="cov0" title="0">{
                        // Log the error but don't fail registration if Redis fails
                        fmt.Printf("Failed to store user registration in Redis: %v\n", err)
                }</span>
        }

        <span class="cov8" title="1">return u, nil</span>
}

func (s *UserService) Authenticate(email, password string) (string, *models.User, error) <span class="cov8" title="1">{
        u, err := s.repo.FindByEmail(email)
        if err != nil </span><span class="cov8" title="1">{
                return "", nil, ErrInvalidCredentials
        }</span>

        <span class="cov8" title="1">if !utils.CompareHash(password, u.Password) </span><span class="cov8" title="1">{
                return "", nil, ErrInvalidCredentials
        }</span>

        // create token
        <span class="cov8" title="1">claims := jwt.MapClaims{
                "sub": u.ID,
                "exp": time.Now().Add(s.expDuration).Unix(),
        }
        t := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        signed, err := t.SignedString([]byte(s.jwtSecret))
        if err != nil </span><span class="cov0" title="0">{
                return "", nil, err
        }</span>

        // Store JWT token in Redis after successful authentication
        <span class="cov8" title="1">if global.Redis != nil </span><span class="cov0" title="0">{
                ctx := context.Background()
                redisKey := fmt.Sprintf("user:token:%d", u.ID)
                if err := global.Redis.Set(ctx, redisKey, signed, s.expDuration).Err(); err != nil </span><span class="cov0" title="0">{
                        // Log the error but don't fail login if Redis fails
                        fmt.Printf("Failed to store user token in Redis: %v\n", err)
                }</span>
        }

        <span class="cov8" title="1">return signed, u, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package testutils

import (
        "bytes"
        "encoding/json"
        "net/http"
        "net/http/httptest"
        "temp/models"

        "github.com/gin-gonic/gin"
        "github.com/stretchr/testify/assert"
)

// CreateTestUser creates a test user with sample data
func CreateTestUser() *models.User <span class="cov0" title="0">{
        return &amp;models.User{
                ID:    1,
                Name:  "Test User",
                Email: "test@example.com",
        }
}</span>

// CreateTestUserWithPassword creates a test user with password
func CreateTestUserWithPassword() *models.User <span class="cov0" title="0">{
        return &amp;models.User{
                ID:       1,
                Name:     "Test User",
                Email:    "test@example.com",
                Password: "$2a$10$N9qo8uLOickgx2ZMRZoMyeIjZAgcfl7p92ldGxad68LJZdL17lhWy", // "password"
        }
}</span>

// CreateTestRequest creates a test HTTP request
func CreateTestRequest(method, url string, body interface{}) *http.Request <span class="cov0" title="0">{
        var buf bytes.Buffer
        if body != nil </span><span class="cov0" title="0">{
                json.NewEncoder(&amp;buf).Encode(body)
        }</span>
        <span class="cov0" title="0">req, _ := http.NewRequest(method, url, &amp;buf)
        req.Header.Set("Content-Type", "application/json")
        return req</span>
}

// AssertJSONResponse asserts that the response matches expected JSON
func AssertJSONResponse(t assert.TestingT, expected interface{}, actual gin.H) <span class="cov0" title="0">{
        expectedJSON, _ := json.Marshal(expected)
        actualJSON, _ := json.Marshal(actual)
        assert.JSONEq(t, string(expectedJSON), string(actualJSON))
}</span>

// CreateTestContext creates a test gin context with request and response recorder
func CreateTestContext(req *http.Request) (*gin.Context, *httptest.ResponseRecorder) <span class="cov0" title="0">{
        gin.SetMode(gin.TestMode)
        w := httptest.NewRecorder()
        c, _ := gin.CreateTestContext(w)
        c.Request = req
        return c, w
}</span>

// SetUserInContext sets a user ID in the gin context for testing
func SetUserInContext(c *gin.Context, userID uint) <span class="cov0" title="0">{
        c.Set("user_id", userID)
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package utils

import "golang.org/x/crypto/bcrypt"

func GenerateHash(pwd string) (string, error) <span class="cov8" title="1">{
        b, err := bcrypt.GenerateFromPassword([]byte(pwd), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return string(b), nil</span>
}

func CompareHash(pwd, hash string) bool <span class="cov8" title="1">{
        if err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(pwd)); err != nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
